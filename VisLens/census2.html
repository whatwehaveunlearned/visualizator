<!DOCTYPE html>
<meta charset="utf-8">
<html>
<head>
	<script  type="text/javascript" src="js/d3.js"></script>
	<script type="text/javascript" src="js/census_query.js"></script>
	<script type="text/javascript" src="js/census_charts.js"></script>
	<script type="text/javascript" src="js/sim_matrix.js"></script>
	<script type="text/javascript" src="js/topojson.v1.min.js"></script>
	<script type="text/javascript" src="js/queue.v1.min.js"></script>
	<script type="text/javascript" src="js/lens_tree_vis.js"></script>

	<!-- cluster selection -->
	<script type="text/javascript" src="js/cluster_selection.js"></script>

	<!-- FFT lib -->
	<script type="text/javascript" src="js/complex_array.js"></script>
	<script type="text/javascript" src="js/fft.js"></script>

	<!-- canvg includes -->
	<script type="text/javascript" src="http://gabelerner.github.io/canvg/rgbcolor.js"></script> 
	<script type="text/javascript" src="http://gabelerner.github.io/canvg/StackBlur.js"></script>
	<script type="text/javascript" src="http://gabelerner.github.io/canvg/canvg.js"></script> 
	<style>
	.countyPath {
		fill: #eeeeee;
		stroke-width: 0.5px;
		stroke: black;
	}
	.node circle {
		fill: steelblue;
		stroke: steelblue;
		stroke-width: 1.5px;
	}
	/*
	.node circle:hover {
		fill: red;
		stroke: red;
		stroke-width: 1.5px;
	}
	*/
	.link {
		fill: none;
		stroke: #ccc;
		stroke-width: 1.5px;
	}

	.line {
		stroke: black;
		stroke-width: 2.5px;
		fill: none;

	}

	.selectionGroup
	{
	}
	</style>
</head>
<body>
	<svg id="svgCanvas" width="1800" height="1000" style="border: dashed 1px #cccccc; position: absolute; left: 0px; top: 0px"></svg>
	<svg id="svgSelection" width="550" height="700" style="position: absolute; left: 1800px; top: 0px; border: dashed 1px #cccccc"></svg>

	<svg id="mapCanvas" width="1000" height="650" style="position: absolute; left: 800px; top: 1000px"></svg>
	<canvas id="matrixCanvas" width="650" height="650" style="position: absolute; left: 75px; top: 1000px"></canvas>
	<svg id="dendogramCanvas" width="75" height="650" style="position: absolute; left: 0px; top: 1000px"></svg>
	
	<script type="text/javascript">

		var MAX_COUNTIES = 5000;
		var TREE_DEPTH_CULL = 8;
		var TREE_SIZE_CULL = false;
		var BRUSH_COLOR = "#f0027f";
		var TREE_COLOR = "steelblue";
		var FULL_MATRIX = true;

		var dataQ = queue(10);
		var states = getStates();
		var countyMap = d3.map();
		var countyList = [];

		drawMap();

		// concatinate all variables
		var variables = [];
		for (var c = 0, len = DEFAULT_CHARTS.length; c < len; c++)
		{
			var chartVars = DEFAULT_CHARTS[c].variables;
			for (var v = 0, vLen = chartVars.length; v < vLen; v++)
				variables.push(chartVars[v]);
		}

		// get data for all states / counties
		var cq = new CensusQuery();
		for (var s = 0, len = states.length; s < len; s++)
		{
			// make a query
			dataQ.defer(function(state, _variables, _cq, _callback) 
			{
				_cq.getCounties(function(err, results) 
				{
					_callback(err, results);
				}, _variables, state);
			}, states[s], variables, cq);
		}

		// data should be ready here
		var lenses = [];

		dataQ.awaitAll(function(error, results)
		{
			if (error) {
				console.warn("\t error: " + error);
			}
			// break down results into arrays
			for (var r = 0, len = results.length; r < len && countyList.length < MAX_COUNTIES; r++)
			{
				var resultBlock = results[r];
				for (var county = 0, cCount = resultBlock.length; county < cCount && countyList.length < MAX_COUNTIES; county++)
				{
					var lens = new VisualLens();
					for (var c = 0, cLen = DEFAULT_CHARTS.length; c < cLen; c++) 
					{
						var curChartVars = DEFAULT_CHARTS[c].variables;
						var chartData = {};
						for (var v = 0, vLen = curChartVars.length; v < vLen; v++)
						{
							var varName = curChartVars[v];
							var varValue = resultBlock[county][varName];
							chartData[ varName ] = varValue;
						}
						var visualFeature = new VisualFeature(DEFAULT_CHARTS[c], chartData);
						//visualFeature.lowpassFilter(0, 0.234);
						lens.addFeature( visualFeature );

					}
					var geoid = +(resultBlock[county].state_num) + "" + resultBlock[county].county;
					countyList.push(geoid);
					countyMap.set(geoid, lens);
				}
			}

			calcMatrix();
		});

		// geo features
		var featureMap = null;
		var features = null;

		// pattern visualizer (i.e., tree)
		var patternVis = null;
		var simMatrix = null;
		var offscreenCanvas = null;
		var clusterSelector = new ClusterSelector(d3.select("#svgSelection"));
		clusterSelector.setBrushCallback( brushCluster, unbrushCluster );

		function calcMatrix()
		{
			var minSim = Number.MAX_VALUE;
			var similarityMatrix = [];
			for (var i = 0, len = countyList.length; i < len; i++) 
			{
				similarityMatrix.push([]);
				var row = similarityMatrix[i];
				for (var j = 0; j < i; j++) {
					var sim = 1.0 - countyMap.get(countyList[i]).distance(countyMap.get(countyList[j]));
					row[j] = sim;
					if (minSim > sim) minSim = sim;
				}
				row[i] = 1.0;

			}

			// refill the other half of the matrix
			for (var i = 0, len = countyList.length; i < len; i++)
				for (var j = i+1; j < len; j++)
					similarityMatrix[i][j] = similarityMatrix[j][i];
			console.log("Clustering...");

			// set dimensions for matrix elements / dendogram
			SIMMAT_ELEMENT_SIZE = .20;
			SIMMAT_ELEMENT_BORDER = "none";
			DENDOGRAM_NODE_HEIGHT = SIMMAT_ELEMENT_SIZE/2 + 2;
			
			var matrixGroup = d3.select("#dendogramCanvas").append("g");
			matrixGroup.attr("transform", "translate(" + d3.select("#dendogramCanvas").attr("width") + ",0)");
			simMatrix = new SimilarityMatrix(matrixGroup);
			simMatrix.setLensAccessor( getLens );
			simMatrix.dendogramLimit = 3;
			simMatrix.setMatrixVisibility(false);
			simMatrix.setDendogramVisibility(true);
			
			// update the similarity matrix 
			simMatrix.updateMatrix(similarityMatrix, minSim);

			// create and render to an offscreen-canvas
			var canvasQ = queue();
			var actualCanvas = document.getElementById('matrixCanvas');
			offscreenCanvas = document.createElement('canvas');
			offscreenCanvas.width = actualCanvas.width;
			offscreenCanvas.height = actualCanvas.height;			
			canvasQ.defer(function(_callback) 
			{
				console.log("rendering matrix...");
				var startTime = new Date();
				simMatrix.drawToCanvas( offscreenCanvas, null, FULL_MATRIX );

				// measure time
				var endTime = new Date();
				var processTime = (endTime.getTime() - startTime.getTime())/1000;
				console.log("matrix rendering took: " + processTime.toFixed(1) + " seconds.");
				actualCanvas.getContext("2d").drawImage(offscreenCanvas, 0, 0);
				_callback(null);
			});
			
			// now create a lens visualization tree and vis it
			var treeSVG = d3.select("#svgCanvas");
			var treeVis = treeSVG.append("g").attr("transform", "translate(0, 0)").attr("id", "treeVis");

			patternVis = new LensTreeVis(simMatrix, treeVis);
			patternVis.setBrushCallback(brushCluster, unbrushCluster);
			patternVis.setClickCallback(selectCluster);
			
			//patternVis.foldUpToDepth(3);
			var treeW = +treeSVG.attr("width");
			var treeH = +treeSVG.attr("height");
			patternVis.visualize_D3Layout_collapsable(treeW, treeH);

			// register zoom
			var svgZoomer = d3.behavior.zoom().on("zoom", function zoom() {
				svgTranslate = "" + d3.event.translate;
				svgScale = "" + d3.event.scale;
				d3.select("#treeVis").attr("transform", "translate(" + svgTranslate + ")scale(" + svgScale + ")");
			});
			svgZoomer( d3.select("#svgCanvas") );
			d3.select("#svgCanvas").on("dblclick.zoom", null);

			function getLens(i)
			{
				var geoid = countyList[i];
				var lens = countyMap.get(geoid);

				return lens;
			}

			simMatrix.setClusterBrushCallback(brushCluster, unbrushCluster);
			simMatrix.setClusterDblClickCallback( toggleClusterFromBottom );
		}

		function selectCluster(cluster)
		{
			if (!d3.event.shiftKey) {
				return;
			}

			if (cluster.isSelected()) 
			{
				clusterSelector.remove(cluster);
				cluster.toggleSelection();
				colorCounties(cluster);
			}
			else
			{
				if (clusterSelector.hasColors()) 
				{
					var color = clusterSelector.add(cluster);
					cluster.toggleSelection(color);
					colorCounties(cluster, color);
				}
			}
		}

		// set brush/unbrush callbacks
		function brushCluster(cluster) 
		{
			// highlight counties in map
			/*
			for (var i = 0, len = cluster.members.length; i < len; i++)
			{
				var countyGeoid = countyList[cluster.members[i]];
				var sel = d3.select("#county_" + countyGeoid);
				sel.style("fill", BRUSH_COLOR);
			}
			*/
			colorCounties(cluster, BRUSH_COLOR);

			// highlight the lens in the tree visualization
			cluster.highlightNode(BRUSH_COLOR);

			// brush the cluster in the pattern tree
			cluster.recursiveBrush(BRUSH_COLOR, "4px", BRUSH_COLOR);

			// highlight selection in the cluster selection widget
			clusterSelector.highlightSelection(cluster, BRUSH_COLOR);

			// draw rectangle around the cluster in the matrix view
			var r = simMatrix.getSize();
			var s = -1;
			for (var k=0, len=cluster.members.length; k<len; k++)
			{
				var i = simMatrix.data2ij[cluster.members[k]];
				if (r > i) r=i;
				if (s < i) s=i;
			}
			r *= SIMMAT_ELEMENT_SIZE;
			s *= SIMMAT_ELEMENT_SIZE;

			if (!offscreenCanvas) return;
			var ctx = document.getElementById("matrixCanvas").getContext("2d");
			ctx.strokeStyle = "black";
			ctx.lineWidth = 3.5;
				
			if (FULL_MATRIX) 
			{
				ctx.strokeRect(r, r, s-r, s-r);
			}
			else
			{
				ctx.beginPath();
				ctx.moveTo(r, r);
				ctx.lineTo(r, s);
				ctx.lineTo(s, s);
				ctx.closePath();
				ctx.stroke();
			}

			// brush dendogram
			simMatrix.highlightCluster(cluster, "red");
		}
		function unbrushCluster(cluster) 
		{
			colorCounties(cluster);

			// remove highlight from the lens in the tree visualization
			cluster.highlightNode();

			// unhighlight corresponding branch in the pattern tree
			cluster.recursiveBrush(TREE_COLOR);

			// unhighlight selection in the cluster selection widget
			clusterSelector.highlightSelection(cluster);

			// redraw matrix from offscreen buffer
			if (offscreenCanvas) {
				var matrixCanvas = document.getElementById("matrixCanvas");
				var context = matrixCanvas.getContext("2d");
				context.clearRect(0, 0, matrixCanvas.width, matrixCanvas.height);
				context.drawImage(offscreenCanvas, 0, 0);
			}

			// unbrush dendogram
			simMatrix.unhighlightCluster(cluster);
		}

		function colorCounties(cluster, color)
		{
			// remove highlight from counties in the map
			for (var i = 0, len = cluster.members.length; i < len; i++)
			{
				var countyGeoid = countyList[cluster.members[i]];
				d3.select("#county_" + countyGeoid).style("fill", color ? color : cluster.resolveColor());
				
			}
			if (cluster.children && !color) 
			{
				var children = cluster.getChildren();
				colorCounties(children[0]);
				colorCounties(children[1]);
			}
		}

		function toggleClusterFromBottom(cluster)
		{
			if (cluster.lastExpandOnDblClick && cluster.lastExpandOnDblClick.isExpanded()) 
			{
				cluster.lastExpandOnDblClick.toggleNode();		
				patternVis.updateTree(cluster.lastExpandOnDblClick);
				cluster.lastExpandOnDblClick = undefined;
			}
			else
			{
				var needUpdate = false;
				var lastParent = null;
				var expandList = [];

				parent = cluster.getParent();
				while (parent) 
				{
					if (!parent.isExpanded()) {
						needUpdate = true;
						//parent.expand();
						expandList.push(parent);
						lastParent = parent;
					}
					parent = parent.getParent();

				}

				// expand in reverse
				for (var i=expandList.length-1; i>=0; i--)
					expandList[i].expand();
				if (needUpdate) 
				{
					cluster.lastExpandOnDblClick = lastParent;
					patternVis.updateTree(lastParent);
					brushCluster(cluster);
				}
			}
		}

		function drawMap()
		{
			var svgMap = d3.select("#mapCanvas");
			var w = +svgMap.attr("width"), h = +svgMap.attr("height");
			var projection = d3.geo.albersUsa().translate([w/2, h/2]).scale(1300);
			var pathGenerator = d3.geo.path().projection(projection);	

			readMap();

			function readMap()
			{
				// read US counties topoplogy
				d3.json("datasets/us-counties.json", function(error, topology)
				{
					if (error) {
						alert("Error getting US counties data: " + error);
						return;
					}
					features = topojson.feature(topology, topology.objects.counties).features;
					
					// make a feature map indexed by county id
					featureMap = d3.map();
					for (var i=0, len=features.length; i < len; i++) {
						featureMap.set(features[i].id, features[i]);
					}
					
					d3.select("#mapCanvas").append("g").selectAll("path")
						.data(features)
						.enter().append("path")
						.classed("countyPath", true)
						.attr("d", pathGenerator)
						.attr("id", function(d) {return "county_" + d.id;});

				});
			}
		}

	</script>
</body>
</html>