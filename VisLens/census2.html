<!DOCTYPE html>
<meta charset="utf-8">
<html>
<head>
	<script  type="text/javascript" src="js/d3.js"></script>
	<script type="text/javascript" src="js/census_query.js"></script>
	<script type="text/javascript" src="js/census_charts.js"></script>
	<script type="text/javascript" src="js/sim_matrix.js"></script>
	<script type="text/javascript" src="js/topojson.v1.min.js"></script>
	<script type="text/javascript" src="js/queue.v1.min.js"></script>
	<script type="text/javascript" src="js/lens_tree_vis.js"></script>

	<!-- cluster selection -->
	<script type="text/javascript" src="js/cluster_selection.js"></script>

	<!-- FFT lib -->
	<script type="text/javascript" src="js/complex_array.js"></script>
	<script type="text/javascript" src="js/fft.js"></script>

	<!-- canvg includes -->
	<script type="text/javascript" src="http://gabelerner.github.io/canvg/rgbcolor.js"></script> 
	<script type="text/javascript" src="http://gabelerner.github.io/canvg/StackBlur.js"></script>
	<script type="text/javascript" src="http://gabelerner.github.io/canvg/canvg.js"></script> 
	<style>
	body
	{
		font-family: sans-serif;
		font-size: 13px;
	}

	.countyPath {
		fill: #eeeeee;
		stroke-width: 0.5px;
		stroke: black;
	}
	.node circle {
		fill: steelblue;
		stroke: steelblue;
		stroke-width: 1.5px;
	}
	.lensRect 
	{
		stroke: #ccc;
		stroke-width: 4.5px;
	}
	.link {
		fill: none;
		stroke: #ccc;
		stroke-width: 1.5px;
	}

	.line {
		stroke: black;
		stroke-width: 2.5px;
		fill: none;

	}

	.selectionRect
	{
		stroke: none;
		stroke-width: 4.5px;
	}
	.selectionGroup
	{
	}

	.countyLabel
	{
	}
	.selectedCountyLabel
	{
		color: white;
		border-radius: 3px;
		border-style: none;
		padding: 1px;
	}
	.statsLabel
	{
		font-size: 19px;
	}
	</style>
</head>
<body>
	<svg id="svgCanvas" width="1780" height="990" style="border: dashed 1px #cccccc; position: absolute; left: 0px; top: 0px"></svg>
	<svg id="svgSelection" width="550" height="650" style="position: absolute; left: 1800px; top: 0px; border: dashed 1px #cccccc"></svg>


	<div style="position: absolute; left: 1800px; top: 650px; font-size: 25px; color: #777777">
	<b>Cluster statistics</b></div>
	<svg id="svgStats" width="550" height="305" style="position: absolute; left: 1800px; top: 685px; border: solid 1px #cccccc"></svg>


	<div style="position: absolute; left: 1800px; top: 1000px; font-size: 25px; color: #777777">
	<b>Counties</b></div>
	<div id="countyList" style="position: absolute; left: 1800px; top: 1035px; border: solid 1px #cccccc; overflow-y: scroll; width: 550px; height: 570px; font-size: 22px">
	</div>

	<svg id="mapCanvas" width="1000" height="650" style="position: absolute; left: 800px; top: 1000px"></svg>
	<canvas id="matrixCanvas" width="650" height="650" style="position: absolute; left: 75px; top: 1000px"></canvas>
	<svg id="dendogramCanvas" width="75" height="650" style="position: absolute; left: 0px; top: 1000px"></svg>
	
	<script type="text/javascript">

		var MAX_COUNTIES = 500;
		var TREE_DEPTH_CULL = 8;
		var TREE_SIZE_CULL = false;
		var BRUSH_COLOR = "#f0027f";
		var TREE_COLOR = "steelblue";
		var FULL_MATRIX = true;

		var dataQ = queue(10);
		var states = getStates();
		var countyMap = d3.map();
		var countyList = [];

		drawMap();

		// concatinate all variables
		var variables = [];
		for (var c = 0, len = DEFAULT_CHARTS.length; c < len; c++)
		{
			var chartVars = DEFAULT_CHARTS[c].variables;
			for (var v = 0, vLen = chartVars.length; v < vLen; v++)
				variables.push(chartVars[v]);
		}

		// get data for all states / counties
		var cq = new CensusQuery();
		for (var s = 0, len = states.length; s < len; s++)
		{
			// make a query
			dataQ.defer(function(state, _variables, _cq, _callback) 
			{
				_cq.getCounties(function(err, results) 
				{
					_callback(err, results);
				}, _variables, state);
			}, states[s], variables, cq);
		}

		// data should be ready here
		var lenses = [];

		dataQ.awaitAll(function(error, results)
		{
			if (error) {
				console.warn("\t error: " + error);
			}
			// break down results into arrays
			for (var r = 0, len = results.length; r < len && countyList.length < MAX_COUNTIES; r++)
			{
				var resultBlock = results[r];
				for (var county = 0, cCount = resultBlock.length; county < cCount && countyList.length < MAX_COUNTIES; county++)
				{
					var lens = new VisualLens();
					for (var c = 0, cLen = DEFAULT_CHARTS.length; c < cLen; c++) 
					{
						var curChartVars = DEFAULT_CHARTS[c].variables;
						var chartData = {};
						for (var v = 0, vLen = curChartVars.length; v < vLen; v++)
						{
							var varName = curChartVars[v];
							var varValue = resultBlock[county][varName];
							chartData[ varName ] = varValue;
						}
						var visualFeature = new VisualFeature(DEFAULT_CHARTS[c], chartData);
						//visualFeature.lowpassFilter(0, 0.234);
						lens.addFeature( visualFeature );

					}
					var geoid = +(resultBlock[county].state_num) + "" + resultBlock[county].county;
					countyList.push(geoid);
					lens.addLabel(resultBlock[county].NAME).addLabel(resultBlock[county].state_abbr)
					countyMap.set(geoid, lens);
				}
			}

			calcMatrix();
		});

		// geo features
		var featureMap = null;
		var features = null;

		// pattern visualizer (i.e., tree)
		var patternVis = null;
		var simMatrix = null;
		var offscreenCanvas = null;
		var clusterSelector = new ClusterSelector(d3.select("#svgSelection"));
		clusterSelector.setBrushCallback( brushCluster, unbrushCluster );
		clusterSelector.setSelectCallback( selectSelection, deselectSelection );

		function calcMatrix()
		{
			var minSim = Number.MAX_VALUE;
			var similarityMatrix = [];
			for (var i = 0, len = countyList.length; i < len; i++) 
			{
				similarityMatrix.push([]);
				var row = similarityMatrix[i];
				for (var j = 0; j < i; j++) {
					var sim = 1.0 - countyMap.get(countyList[i]).distance(countyMap.get(countyList[j]));
					row[j] = sim;
					if (minSim > sim) minSim = sim;
				}
				row[i] = 1.0;

			}

			// refill the other half of the matrix
			for (var i = 0, len = countyList.length; i < len; i++)
				for (var j = i+1; j < len; j++)
					similarityMatrix[i][j] = similarityMatrix[j][i];
			console.log("Clustering...");

			// set dimensions for matrix elements / dendogram
			SIMMAT_ELEMENT_SIZE = .20;
			SIMMAT_ELEMENT_BORDER = "none";
			DENDOGRAM_NODE_HEIGHT = SIMMAT_ELEMENT_SIZE/2 + 2;
			
			var matrixGroup = d3.select("#dendogramCanvas").append("g");
			matrixGroup.attr("transform", "translate(" + d3.select("#dendogramCanvas").attr("width") + ",0)");
			simMatrix = new SimilarityMatrix(matrixGroup);
			simMatrix.setLensAccessor( getLens );
			simMatrix.dendogramLimit = 3;
			simMatrix.setMatrixVisibility(false);
			simMatrix.setDendogramVisibility(true);
			
			// update the similarity matrix 
			simMatrix.updateMatrix(similarityMatrix, minSim);

			// create and render to an offscreen-canvas
			var canvasQ = queue();
			var actualCanvas = document.getElementById('matrixCanvas');
			offscreenCanvas = document.createElement('canvas');
			offscreenCanvas.width = actualCanvas.width;
			offscreenCanvas.height = actualCanvas.height;			
			canvasQ.defer(function(_callback) 
			{
				console.log("rendering matrix...");
				var startTime = new Date();
				simMatrix.drawToCanvas( offscreenCanvas, null, FULL_MATRIX );

				// measure time
				var endTime = new Date();
				var processTime = (endTime.getTime() - startTime.getTime())/1000;
				console.log("matrix rendering took: " + processTime.toFixed(1) + " seconds.");
				actualCanvas.getContext("2d").drawImage(offscreenCanvas, 0, 0);
				_callback(null);
			});
			
			// now create a lens visualization tree and vis it
			var treeSVG = d3.select("#svgCanvas");
			var treeVis = treeSVG.append("g").attr("transform", "translate(0, 0)").attr("id", "treeVis");

			patternVis = new LensTreeVis(simMatrix, treeVis);
			patternVis.setBrushCallback(brushCluster, unbrushCluster);
			patternVis.setClickCallback(selectCluster);
			
			//patternVis.foldUpToDepth(3);
			var treeW = +treeSVG.attr("width");
			var treeH = +treeSVG.attr("height");
			patternVis.visualize_D3Layout_collapsable(treeW, treeH);

			// register zoom
			var svgZoomer = d3.behavior.zoom().on("zoom", function zoom() {
				svgTranslate = "" + d3.event.translate;
				svgScale = "" + d3.event.scale;
				d3.select("#treeVis").attr("transform", "translate(" + svgTranslate + ")scale(" + svgScale + ")");
			});
			svgZoomer( d3.select("#svgCanvas") );
			d3.select("#svgCanvas").on("dblclick.zoom", null);

			function getLens(i)
			{
				var geoid = countyList[i];
				var lens = countyMap.get(geoid);

				return lens;
			}

			simMatrix.setClusterBrushCallback(brushCluster, unbrushCluster);
			simMatrix.setClusterDblClickCallback( toggleClusterFromBottom );
		}

		function selectCluster(cluster)
		{
			if (!d3.event.shiftKey) {
				return;
			}

			if (cluster.isSelected()) 
			{
				clusterSelector.remove(cluster);
				cluster.toggleSelection();
				highlightCounties(cluster);
			}
			else
			{
				if (clusterSelector.hasColors()) 
				{
					var color = clusterSelector.add(cluster);
					cluster.toggleSelection(color);
					highlightCounties(cluster, color);
				}
			}
		}

		// set brush/unbrush callbacks
		function brushCluster(cluster) 
		{
			// highlight counties in map
			/*
			for (var i = 0, len = cluster.members.length; i < len; i++)
			{
				var countyGeoid = countyList[cluster.members[i]];
				var sel = d3.select("#county_" + countyGeoid);
				sel.style("fill", BRUSH_COLOR);
			}
			*/
			highlightCounties(cluster, BRUSH_COLOR);

			// highlight the lens in the tree visualization
			cluster.highlightNode(BRUSH_COLOR);

			// brush the cluster in the pattern tree
			cluster.recursiveBrush(BRUSH_COLOR, "4px", BRUSH_COLOR);

			// highlight selection in the cluster selection widget
			clusterSelector.highlightSelection(cluster, BRUSH_COLOR);

			// draw rectangle around the cluster in the matrix view
			var r = simMatrix.getSize();
			var s = -1;
			for (var k=0, len=cluster.members.length; k<len; k++)
			{
				var i = simMatrix.data2ij[cluster.members[k]];
				if (r > i) r=i;
				if (s < i) s=i;
			}
			r *= SIMMAT_ELEMENT_SIZE;
			s *= SIMMAT_ELEMENT_SIZE;

			if (!offscreenCanvas) return;
			var ctx = document.getElementById("matrixCanvas").getContext("2d");
			ctx.strokeStyle = "black";
			ctx.lineWidth = 3.5;
				
			if (FULL_MATRIX) 
			{
				ctx.strokeRect(r, r, s-r, s-r);
			}
			else
			{
				ctx.beginPath();
				ctx.moveTo(r, r);
				ctx.lineTo(r, s);
				ctx.lineTo(s, s);
				ctx.closePath();
				ctx.stroke();
			}

			// brush dendogram
			simMatrix.highlightCluster(cluster, "red");
		}
		function unbrushCluster(cluster) 
		{
			highlightCounties(cluster);

			// remove highlight from the lens in the tree visualization
			cluster.highlightNode();

			// unhighlight corresponding branch in the pattern tree
			cluster.recursiveBrush(TREE_COLOR);

			// unhighlight selection in the cluster selection widget
			clusterSelector.highlightSelection(cluster);

			// redraw matrix from offscreen buffer
			if (offscreenCanvas) {
				var matrixCanvas = document.getElementById("matrixCanvas");
				var context = matrixCanvas.getContext("2d");
				context.clearRect(0, 0, matrixCanvas.width, matrixCanvas.height);
				context.drawImage(offscreenCanvas, 0, 0);
			}

			// unbrush dendogram
			simMatrix.unhighlightCluster(cluster);
		}

		function selectSelection(selection)
		{
			var members = selection.getCluster().getMembers();
			var counties = [];

			for (var i=0, len=members.length; i < len; i++) 
			{
				var index = members[i];
				var geoid = countyList[index];
				var lens = countyMap.get( geoid );	
				var labels = lens.getLabels();

				counties.push(
				{
					index: index,
					geoid: geoid,
					countyName: labels[0],
					state: labels[1]
				});
			}

			// sort county list by state and then name
			counties.sort(function(a, b) 
			{
				var state = a.state.localeCompare(b.state);
				if (state === 0)
					return a.countyName.localeCompare(b.countyName);
				else
					return state;
			});

			d3.select("#countyList").selectAll("span").data(counties).enter()
				.append("span")
				.attr("class", "countyLabel")
				.html(function(county) { return county.countyName + ", " + county.state + "<br>"; })
				.on("mouseover", function(county) 
				{
					d3.select(this).attr("class", "selectedCountyLabel").style("background-color", BRUSH_COLOR);
					highlightIndividualCounty(county.index, BRUSH_COLOR);
				})
				.on("mouseout", function(county) 
				{
					d3.select(this).attr("class", "countyLabel").style("background-color", "");
					highlightIndividualCounty(county.index);
				});
			drawClusterStats(selection);
		}

		function deselectSelection(selection)
		{
			d3.select("#countyList").html("");
			clearClusterStats();
		}

		function highlightIndividualCounty(countyNumber, color)
		{
			var countyGeoid = countyList[countyNumber];
			d3.select("#county_" + countyGeoid).style("fill", color ? color : simMatrix.getEntryClusters().get(countyNumber).resolveColor());
		}
		function highlightCounties(cluster, color)
		{
			// remove highlight from counties in the map
			for (var i = 0, len = cluster.members.length; i < len; i++)
			{
				var countyGeoid = countyList[cluster.members[i]];
				d3.select("#county_" + countyGeoid).style("fill", color ? color : cluster.resolveColor());
				
			}
			if (cluster.children && !color) 
			{
				var children = cluster.getChildren();
				highlightCounties(children[0]);
				highlightCounties(children[1]);
			}
		}

		function toggleClusterFromBottom(cluster)
		{
			if (cluster.lastExpandOnDblClick && cluster.lastExpandOnDblClick.isExpanded()) 
			{
				cluster.lastExpandOnDblClick.toggleNode();		
				patternVis.updateTree(cluster.lastExpandOnDblClick);
				cluster.lastExpandOnDblClick = undefined;
			}
			else
			{
				var needUpdate = false;
				var lastParent = null;
				var expandList = [];

				parent = cluster.getParent();
				while (parent) 
				{
					if (!parent.isExpanded()) {
						needUpdate = true;
						//parent.expand();
						expandList.push(parent);
						lastParent = parent;
					}
					parent = parent.getParent();

				}

				// expand in reverse
				for (var i=expandList.length-1; i>=0; i--)
					expandList[i].expand();
				if (needUpdate) 
				{
					cluster.lastExpandOnDblClick = lastParent;
					patternVis.updateTree(lastParent);
					brushCluster(cluster);
				}
			}
		}

		var STATS_CHART_W = 180;
		var STATS_CHART_H = 100;
		var STATS_LABEL_SIZE = 20;
		var STATS_PAD_W = 30;
		var STATS_PAD_H = 20;
		var STATS_BINS = 60;

		function clearClusterStats()
		{
			d3.select("#svgStats").selectAll("g.statsGroup").remove();
		}

		function drawClusterStats(selection)
		{
			var OFFSET = 30;


			var statsGroup = d3.select("#svgStats").append("g").attr("class", "statsGroup");
			
			var Y = OFFSET;
			var variabilityChart = drawClusterVariabilityChart(
				selection, 
				statsGroup.append("g")
					.attr("class", "chartGroup")
					.attr("transform", "translate(" + OFFSET + "," + Y + ")")
			);
			
			statsGroup.append("text")
				.html("centroid distance variance")
				.attr("x", (variabilityChart.length*STATS_CHART_W + (variabilityChart.length > 1 ? variabilityChart.length-1 : 0)*STATS_PAD_W)/2)
				.attr("y", OFFSET+STATS_CHART_H+STATS_LABEL_SIZE)
				.attr("class", "statsLabel")
				.attr("text-anchor", "middle");

			Y += STATS_CHART_H + STATS_PAD_H + STATS_LABEL_SIZE;
			var pairDistanceChart = drawPairDistanceVariabilityChart(
				selection, 
				statsGroup.append("g")
					.attr("class", "chartGroup")
					.attr("transform", "translate(" + OFFSET + "," + Y + ")")
			);
			
			Y += STATS_CHART_H + STATS_LABEL_SIZE;
			statsGroup.append("text")
				.html("pairwise distance variance")
				.attr("x", (pairDistanceChart.length*STATS_CHART_W + (pairDistanceChart.length > 1 ? variabilityChart.length-1 : 0)*STATS_PAD_W)/2)
				.attr("y", Y)
				.attr("class", "statsLabel")
				.attr("text-anchor", "middle");
		}

		function drawClusterVariabilityChart(selection, chartGroup)
		{
			var entryClusters = simMatrix.getEntryClusters();
			var all_variability = selection.getCluster().intraclusterVariability(function(memberI) {
				return entryClusters.get(memberI);
			});

			var histograms = [];
			for (var f=0, featureCount = all_variability.length; f < featureCount; f++)
			{
				var g = chartGroup.append("g").attr("transform", "translate(" + f*(STATS_CHART_W+STATS_PAD_W) + ",0)");
				var histogram = plotStatsHistogram(g, all_variability[f]);
				histograms.push(histogram)
			}
			return histograms;
		}
		function drawPairDistanceVariabilityChart(selection, chartGroup)
		{
			var entryClusters = simMatrix.getEntryClusters();
			var all_variability = selection.getCluster().pairwiseVariability(function(memberI) {
				return entryClusters.get(memberI);
			});

			var histograms = [];
			for (var f=0, featureCount = all_variability.length; f < featureCount; f++)
			{
				var g = chartGroup.append("g").attr("transform", "translate(" + f*(STATS_CHART_W+STATS_PAD_W) + ",0)");
				var histogram = plotStatsHistogram(g, all_variability[f]);
				histograms.push(histogram)
			}
			return histograms;			
		}

		function plotStatsHistogram(chartGroup, data)
		{
			var minmax = d3.extent(data);
			var stepSize = (minmax[1]-minmax[0]) / STATS_BINS;
				
			var bins = [];
			for (var i=0; i<STATS_BINS; i++)
				bins.push(0);
				
			var binsMax = 0;
			for (var i=0, len=data.length; i < len; i++) 
			{
				var k = Math.floor((data[i]-minmax[0]) / stepSize);
				k = Math.max(0, Math.min(k, STATS_BINS-1));
				var b = ++bins[k];
				if (binsMax < b) binsMax = b;
			}

			var histogram = new Histogram(bins, STATS_CHART_W, STATS_CHART_H, chartGroup, binsMax);
			chartGroup.append("line")
				.attr("x1", 0).attr("y1", STATS_CHART_H)
				.attr("x2", STATS_CHART_W).attr("y2", STATS_CHART_H)
				.style("stroke", "#444444").style("stroke-width", "1px");

			chartGroup.selectAll("rect").style("fill", "#aaaaaa");
			return histogram
		}

		function drawMap()
		{
			var svgMap = d3.select("#mapCanvas");
			var w = +svgMap.attr("width"), h = +svgMap.attr("height");
			var projection = d3.geo.albersUsa().translate([w/2, h/2]).scale(1300);
			var pathGenerator = d3.geo.path().projection(projection);	

			readMap();

			function readMap()
			{
				// read US counties topoplogy
				d3.json("datasets/us-counties.json", function(error, topology)
				{
					if (error) {
						alert("Error getting US counties data: " + error);
						return;
					}
					features = topojson.feature(topology, topology.objects.counties).features;
					
					// make a feature map indexed by county id
					featureMap = d3.map();
					for (var i=0, len=features.length; i < len; i++) {
						featureMap.set(features[i].id, features[i]);
					}
					
					d3.select("#mapCanvas").append("g").selectAll("path")
						.data(features)
						.enter().append("path")
						.classed("countyPath", true)
						.attr("d", pathGenerator)
						.attr("id", function(d) {return "county_" + d.id;});

				});
			}
		}

	</script>
</body>
</html>